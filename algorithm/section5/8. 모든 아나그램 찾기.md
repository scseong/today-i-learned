## 모든 아나그램 찾기(Hash, Sliding Window, Two Pointers)

### 1. 문제 정보

- **문제 제목**: 모든 아나그램 찾기(Hash, Sliding Window, Two Pointers)
- **카테고리**: 효율성, 해쉬, 슬라이딩 윈도우, 두 포인터

### 2. 문제 설명

- **핵심 목표**: 긴 문자열 S 내에서 짧은 문자열 T의 아나그램이 되는 연속된 부분 문자열의 개수를 찾는다.
- **제한 사항**:
  - S 문자열 길이 <= 10,000
  - T 문자열 길이 <= S 문자열 길이
  - 대소문자 구분
- **입출력 예시**:
  - Input: S: bacaAacba / T: abc
  - Output: 3

### 3. 접근 방식 및 알고리즘

- **사용한 알고리즘**:
  1. 해쉬 맵: S의 부분 구간과 T의 문자 빈도수를 비교
  2. 슬라이딩 윈도우: T의 길이만큼 창문을 유지하며 오른쪽으로 이동
  3. 투 포인터: 시작(lt) 끝(rt) 인덱스 관리
- **풀이 로직**:
  1. T 전체의 해쉬와 S의 첫 구간(len-1까지) 해쉬 생성
  2. rt를 이동시키며 새로운 문자를 sH에 추가
  3. sH와 tH의 size가 같고, tH의 모든 키-값 쌍이 sH와 일치하는지 확인
  4. lt가 가리키는 값을 감소시키고 빈도가 0이 되면 Map에서 삭제

### 4. 성능 측정 결과 (Performance)

| **구분**       | **실행 시간 (평균)** | **시간 복잡도** | **공간 복잡도** |
| -------------- | -------------------- | --------------- | --------------- |
| **Solution 1** | **0.1599ms**         | O(N)            | O(M)            |

---

## 💻 JavaScript 풀이 코드

Solution 1: 슬라이딩 윈도우 이동 시마다 Map의 상태를 비교하여 아나그램 개수 카운팅

```js
function solution1(s, t) {
  let answer = 0;
  let len = t.length;

  let sH = new Map();
  let tH = new Map();

  // 1. 초기 해쉬 세팅: T 전체와 S의 초기 구간(len-1)
  for (let count = 0; count < len; count++) {
    tH.set(t[count], (tH.get(t[count]) || 0) + 1);

    if (count === len - 1) continue;
    sH.set(s[count], (sH.get(s[count]) || 0) + 1);
  }

  let lt = 0;
  // 2. 슬라이딩 윈도우 시작
  for (let rt = len - 1; rt < s.length; rt++) {
    sH.set(s[rt], (sH.get(s[rt]) || 0) + 1);

    // 3. 아나그램 확인 (Size와 Key-Value 일치 여부)
    let temp = true;
    for (const [key, value] of tH) {
      if (sH.size !== tH.size || sH.get(key) !== value) {
        temp = false;
        break;
      }
    }
    if (temp) answer++;

    // 4. 왼쪽 값 제거 및 윈도우 이동
    sH.set(s[lt], sH.get(s[lt]) - 1);
    if (!sH.get(s[lt])) sH.delete(s[lt]);
    lt++;
  }

  return answer;
}
```
