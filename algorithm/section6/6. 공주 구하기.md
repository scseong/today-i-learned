## 공주 구하기

### 1. 문제 정보

- **문제 제목**: 공주 구하기
- **카테고리**: 자료구조, 큐(Queue)

### 2. 문제 설명

- **핵심 목표**: N명의 왕자가 원형으로 앉아 1부터 번호를 외치다가, K를 외친 왕자를 제외하는 과정을 반복하여 마지막에 남는 왕자의 번호를 찾는다.
- **제한 사항**:
  - N(5<=N<=1,000)m K(2<=K<=9)
- **입출력 예시**:
  - Input: 8 3
  - Output: 7

### 3. 접근 방식 및 알고리즘

- **사용한 알고리즘**:
  1. 자료구조(Queue)
  2. 인덱스 연산 (Splice & Modulo)
- **풀이 로직**:
  1. 자료구조(Queue)
  - 큐에 1부터 N까지 넣은 후 K-1번 동안 맨 앞 요소를 빼서 뒤로 다시 삽입
  - K번째 요소 제거
  2. Splice & Modulo 연산
  - 현재 인덱스에서 K-1을 더한 위치를 계산
  - 배열의 현재 길이로 나머지 연산(%)을 수행하여 원형 인덱스를 계산 후 제거

### 4. 성능 측정 결과 (Performance)

| **구분**       | **실행 시간 (평균)** | **시간 복잡도** | **공간 복잡도** |
| -------------- | -------------------- | --------------- | --------------- |
| **Solution 1** | **0.0639ms**         | O(N x K)        | O(N)            |
| **Solution 2** | **0.0556ms**         | O(N^2)          | O(N)            |

---

## 💻 JavaScript 풀이 코드

Solution 1: Queue

```js
function solution1(n, k) {
  let queue = Array.from({ length: n }, (_, i) => i + 1);

  while (queue.length > 1) {
    for (let i = 1; i < k; i++) queue.push(queue.shift());
    queue.shift();
  }

  return queue[0];
}
```

Solution 2: Splice & Modulo

```js
function solution2(n, k) {
  let queue = Array.from({ length: n }, (_, i) => i + 1);
  let out = k - 1;

  while (queue.length > 1) {
    queue.splice(out, 1);
    out = (out + k - 1) % queue.length;
  }

  return queue[0];
}
```
