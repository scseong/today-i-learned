## 멘토링

### 1. 문제 정보

- **문제 제목**: 멘토링
- **카테고리**: 완전탐색

### 2. 문제 설명

- **핵심 목표**: M번의 테스트에서 항상 A학생이 B학생보다 등수가 높은 멘토-멘티 조합 (A, B)의 총 개수를 구한다.
- **제한 사항**:
  - 학생 수 N (1 ≤ N ≤ 20)
  - 테스트 횟수 M (1 ≤ M ≤ 10)
  - 모든 테스트에서 멘토가 멘티보다 등수가 앞서야 함.
- **입출력 예시**:
  - Input:
    ```
    4 3
    3 4 1 2
    4 3 2 1
    3 1 4 2
    ```
  - Output: 3

### 3. 접근 방식 및 알고리즘

- **사용한 알고리즘**:
  1. 후보군 소거
- **풀이 로직**:
  1. 초기화: Map을 생성하여 각 학생마다 자기 자신을 제외한 나머지 모든 학생을 담은 Set을 할당 (초기에는 모두가 멘티 후보)
  2. 3중 반복문 수행
  - 각 테스트(i)의 각 등수(j)를 순회
  - 현재 확인 중인 학생(arr[i][j])보다 앞서 있는 학생들(인덱스 k < j)을 탐색
  - 현재 시험에서 나보다 앞에 있는 학생은 나의 멘티가 될 수 없으므로 Set에서 해당 학생을 delete
  3. 모든 테스트가 끝난 후 각 Set에 남아있는 요소의 개수를 합산

### 4. 성능 측정 결과 (Performance)

| **구분**       | **실행 시간 (평균)** | **시간 복잡도**                                  | **공간 복잡도** |
| -------------- | -------------------- | ------------------------------------------------ | --------------- |
| **Solution 1** | **0.3358ms**         | O(M x N^2) (테스트 수 M, 학생 수 N, 비교 연산 N) | O(N^2)          |

---

## 💻 JavaScript 풀이 코드

Solution 1: 첫 번째 시험 등수를 기준으로 후보군을 만들고 시험들을 거치며 후보군에서 탈락

```js
function solution1(n, arr) {
  let answer = 0;

  // 1. 학생별 잠재적 멘티 후보군 초기화 (자기 자신 제외)
  const obj = new Map(
    arr[0].map((key) => [
      key,
      new Set(
        Array.from({ length: n }, (_, i) => i + 1).filter((id) => id !== key)
      ),
    ])
  );

  // 2. 모든 테스트를 순회하며 후보군 소거
  for (let i = 0; i < arr.length; i++) {
    for (let j = 0; j < arr[i].length; j++) {
      const mentor = arr[i][j];
      const mentorSet = obj.get(mentor);

      if (!mentorSet.size) continue; // 후보가 없으면 스킵

      // 현재 멘토보다 앞에 있는 학생들은 멘티가 될 수 없음
      for (let k = 0; k < j; k++) {
        const higherRanker = arr[i][k];
        mentorSet.delete(higherRanker);
      }
    }
  }

  // 3. 최종 남은 후보수 합산
  obj.forEach((t) => (answer += t.size));
  return answer;
}
```
