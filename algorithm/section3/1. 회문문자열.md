## 회문문자열

### 1. 문제 정보

- **문제 제목**: 회문 문자열
- **카테고리**: 문자열 탐색

### 2. 문제 설명

- **핵심 목표**: 대소문자를 구분하지 않고 앞에서 읽으나 뒤에서 읽으나 동일한 문자열인지 판별
- **제한 사항**: 문자열 길이 100 이하 (매우 작음), 공백 없음
- **입출력 예시**:
  - input: "gooG" -> output: "YES" (대소문자 무시하면 "goog"로 동일)

### 3. 접근 방식 및 알고리즘

- **사용한 알고리즘**:
  1. 직접 비교: 문자열의 양 끝에서 중앙으로 가며 한 글자씩 비교
  2. 내장 메서드 활용: 문자열을 뒤집어서 원본과 비교
- **풀이 로직**:
  1. for문을 사용하여 인덱스 `i`와 `length-i-1`을 직접 비교
  2. `split(''), reverse(), join('')` 문자열을 뒤집어서 원본 문자열과 비교

### 4. 성능 측정 결과 (Performance)

| **구분**       | **실행 시간 (평균)** | **시간 복잡도** | **공간 복잡도** |
| -------------- | -------------------- | --------------- | --------------- |
| **Solution 1** | **0.0452ms**         | O(N)            | O(N)            |
| **Solution 2** | **0.0605ms**         | O(N)            | O(N)            |

---

## 💻 JavaScript 풀이 코드

Solution 1: 반복문을 이용한 직접 비교

```js
function solution1(str) {
  const s = str.toLowerCase();
  const n = Math.floor(s.length / 2);

  for (let i = 0; i < n; i++) {
    // 대칭 위치의 문자와 비교
    if (s[i] !== s[s.length - i - 1]) {
      return "NO";
    }
  }
  return "YES";
}
```

Solution 2: 내장 메서드를 이용한 문자열 뒤집기

```js
function solution2(str) {
  const s = str.toLowerCase();

  if (s !== s.split("").reverse().join("")) {
    return "NO";
  }
  return "YES";
}
```
